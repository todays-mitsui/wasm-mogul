---
title: "式: Expression"
---

Tuber における**式**は以下のような 変数, シンボル, 関数適用、ラムダ抽象 の組み合わせです。

## 変数: Variable

変数は英数字とアンダースコアからなる文字の並びです。
変数名に使える文字は以下のようになります。

- 英小文字 `a-z`
- 英大文字 `A-Z`
- 数字 `0-9`
- アンダースコア `_`

ただし英小文字 `a-z` については必ず 1 文字で 1 つの変数と認識されます。例えば `cat` という文字の並びは 3 つの変数 `c`, `a`, `t` が連なったものとして認識されます。
英小文字以外の文字については複数文字を並べて使うことが可能です。例えば `CAT` は 1 つの識別子として認識されます。

例として以下は全て正しい変数として使用可能です。

- `a`
- `x`
- `_`
- `VAR`
- `42`

`42` が整数リテラル**ではない**ことに注意してください。
Tuber には "数" は登場しません。`42` はただの変数でしかなく、どのような意味を持つかは全体の式やコンテキスに依ります。

ただし、関数定義によって `42` と関数を紐付けることで `42` があたかも 42 という数として振る舞うようにすることは可能です。
詳しくは [自然数を扱う例](#) を参照してください。

## シンボル: Symbol

シンボルはコロン `:` から始まり英数字とアンダースコアが続く文字の並びです。
シンボル名に使える文字のルールは変数と同じです。

例として以下は全て正しいシンボルとして使用可能です。

- `:a`
- `:x`
- `:_`
- `:VAR`
- `:42`

シンボルと変数はどう違うのでしょうか？最大の違いは関数定義によって関数と紐付け可能かという点です。
変数は関数定義によって関数と紐付けることが可能です。一方でシンボルは関数と紐付けることができません。故にシンボルはただのシンボルでしかないということです。

なぜシンボルが必要なのか詳しい事情は [変数とシンボル](#) の項を参照してください。

## 関数適用: application

二つの式を関数適用によって合成し、一つの式として取り扱うことが可能です。
ECMAScript スタイルではパーレン `()` を使って関数呼び出しのように表現します。Lazy_K スタイルではバッククォート `` ` `` 前置することで表現します。

例として変数 `x` に変数 `f` を適用するには以下のように書きます。

```
# ECMAScript スタイル
f(x)

# Lazy_K スタイル
`fx
```

ECMAScript スタイルでは適用する式と適用される式を明確にするために、適用する式をパーレンで囲む必要があるかも知れません。
例えば変数 `a` に式 `x => x` を適用するには以下のように書きます。

```
(x => x)(a)


# パーレンを省くと `x => (x(a)) と解釈される
x => x(a)
```

一方で Lazy_K スタイルは複雑な組み合わせの関数適用でもパーレンを必要としない点が優れています。
以下の式はどれも一意に解釈されます。

````
`^x.xa   # (x => x)(a) と同等

^x.`xa   # x => x(a) と同等

```xzyz  # x(z, y, z) と同等

``xz`yz  # x(z, y(z)) と同等
````

## ラムダ抽象: lambda

ラムダ抽象
